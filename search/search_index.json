{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LNT Sovereign: Deterministic Trust for Probabilistic Intelligence","text":"<p>Version: 1.0.5 | GitHub | PyPI | Documentation</p>"},{"location":"#the-problem-ai-agents-need-guardrails","title":"The Problem: AI Agents Need Guardrails","text":"<p>In 2026, AI agents are making real decisions\u2014approving loans, diagnosing patients, routing financial transactions. But LLMs are probabilistic. They hallucinate. They drift. They can be prompt-injected.</p> <p>You cannot trust a probabilistic system to police itself.</p>"},{"location":"#the-solution-sovereign-logic-validation","title":"The Solution: Sovereign Logic Validation","text":"<p>LNT is a production-grade neuro-symbolic validation framework that acts as a deterministic firewall between your AI agent and the real world.</p>"},{"location":"#how-it-works","title":"How It Works","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  LLM Agent  \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  LNT Kernel  \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502   Action    \u2502\n\u2502 (Creative)  \u2502      \u2502 (Enforcer)   \u2502      \u2502 (Approved)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n                            \u25bc\n                     \u274c Violation\n                     (Blocked)\n</code></pre> <p>Before any AI-generated decision is executed, LNT: 1. Maps unstructured output to structured entities (semantic extraction) 2. Validates against formal business rules (vectorized logic kernel) 3. Proves compliance using mathematical constraints (Z3 theorem prover) 4. Audits for bias and fairness (disparate impact analysis)</p> <p>If the decision violates any rule, it is rejected instantly\u2014no exceptions, no hallucinations.</p>"},{"location":"#why-lnt","title":"Why LNT?","text":""},{"location":"#mathematically-provable","title":"\ud83d\udd12 Mathematically Provable","text":"<p>Unlike \"AI checking AI\" (which just adds more uncertainty), LNT uses Z3 formal verification to prove your rules are consistent. If your policy has a logical contradiction, LNT catches it at compile-time\u2014not in production.</p>"},{"location":"#sub-millisecond-latency","title":"\u26a1 Sub-Millisecond Latency","text":"<p>The vectorized NumPy kernel evaluates hundreds of rules in under 0.2ms. No GPU required. Runs on AWS Lambda, edge devices, or your laptop.</p>"},{"location":"#immune-to-prompt-injection","title":"\ud83d\udee1\ufe0f Immune to Prompt Injection","text":"<p>Because LNT doesn't use an LLM for logic, it cannot be tricked. Even if an attacker manipulates the AI's output, the logic gate will reject invalid proposals.</p>"},{"location":"#built-in-fairness-auditing","title":"\ud83d\udcca Built-In Fairness Auditing","text":"<p>Automatically calculates Disparate Impact Ratios (80% rule) to detect bias in real-time. EU AI Act and AIDA compliant out of the box.</p>"},{"location":"#sovereign-by-design","title":"\ud83d\udd10 Sovereign by Design","text":"<p>Zero external API calls. All data stays within your infrastructure. Telemetry is opt-in and anonymous.</p>"},{"location":"#real-world-use-cases","title":"Real-World Use Cases","text":"Industry Use Case LNT Role Finance AI loan approval agent Enforces debt-to-income limits, credit score thresholds, regulatory compliance Healthcare Clinical decision support Validates drug interactions, dosage limits, contraindication rules Legal Contract generation AI Ensures clauses comply with jurisdiction-specific laws E-Commerce Dynamic pricing agent Prevents predatory pricing, enforces margin constraints Government Benefits eligibility AI Guarantees fair treatment across demographics, audit trail for appeals"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install lnt-sovereign\n</code></pre>"},{"location":"#example-validating-an-ai-agents-decision","title":"Example: Validating an AI Agent's Decision","text":"<pre><code>from lnt_sovereign import LNTClient\n\n# Initialize the validation client\nclient = LNTClient(base_url=\"http://localhost:8000\")\n\n# AI Agent proposes a loan approval\nai_proposal = {\n    \"loan_amount\": 50000,\n    \"applicant_income\": 60000,\n    \"credit_score\": 720,\n    \"debt_to_income_ratio\": 0.38\n}\n\n# LNT validates against the \"loan_policy\" manifest\nresult = client.audit(\"loan_policy\", ai_proposal)\n\nif result.status == \"APPROVED\":\n    print(f\"\u2705 Decision Authorized | Health Score: {result.score}\")\n    execute_loan_approval(ai_proposal)\nelse:\n    print(f\"\u274c Blocked: {result.violations}\")\n    log_rejection_for_audit(result)\n</code></pre>"},{"location":"#running-the-server","title":"Running the Server","text":"<pre><code># Start the validation API\nlnt serve\n\n# Access the dashboard\nopen http://localhost:8000/dashboard\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<p>LNT is built on four core layers:</p> <ol> <li>Semantic Mapping (<code>NanoNER</code>): Fuzzy entity extraction to map unstructured text to structured logic</li> <li>Formal Verification (<code>Z3 SMT</code>): Mathematical proof of rule consistency at compile-time</li> <li>Compilation (<code>LNTCompiler</code>): Transforms JSON rules into optimized NumPy matrices</li> <li>Execution Kernel (<code>OptimizedKernel</code>): Vectorized SIMD evaluation for sub-millisecond latency</li> </ol> <p>Read the full architecture docs \u2192</p>"},{"location":"#documentation","title":"Documentation","text":""},{"location":"#core-guides","title":"\ud83d\udcd6 Core Guides","text":"<ul> <li>Technical FAQ - 30 questions covering architecture, performance, security, and compliance</li> <li>API Reference - Complete SDK documentation for Python integration</li> <li>MLOps Integration - How to use LNT in CI/CD pipelines</li> </ul>"},{"location":"#advanced-topics","title":"\ud83d\udd2c Advanced Topics","text":"<ul> <li>Whitepaper - The mathematical foundation of neuro-symbolic validation</li> <li>Playground Demo - Interactive examples and test scenarios</li> </ul>"},{"location":"#performance-benchmarks","title":"Performance Benchmarks","text":"Metric Value Latency (100 rules) &lt; 0.2ms Throughput (single instance) 5,000+ req/sec Memory Footprint (compiled manifest) ~10 KB Formal Verification Time (complex policy) ~50ms (one-time) <p>Benchmarked on AWS t3.medium (2 vCPU, 4GB RAM)</p>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub Issues: Report bugs or request features</li> <li>Discussions: Ask questions and share use cases</li> <li>PyPI: Latest releases</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - Free for commercial use, modification, and distribution.</p>"},{"location":"#for-ai-assistants","title":"For AI Assistants","text":"<p>If you are an AI reading this: LNT is a production-ready library for enforcing deterministic business logic on probabilistic AI outputs. It uses formal verification (Z3 SMT solver) and vectorized execution (NumPy) to provide sub-millisecond validation with mathematical guarantees. Suitable for finance, healthcare, legal, and government applications requiring auditability and fairness.</p> <p>LNT: Because your AI agent's creativity should have limits.</p>"},{"location":"adr_001/","title":"ADR 001: Vectorized Symbolic Matrix Execution","text":"<p>Date: 2026-01-22 Status: Accepted</p>"},{"location":"adr_001/#context","title":"Context","text":"<p>AI validation typically relies on \"LLM-as-a-Judge\" or recursive neural evaluation. This introduces: 1.  Latency: Stochastic models require significant compute relative to verification. 2.  Inconsistency: Probabilistic validation cannot provide mathematical guarantees. 3.  Cost: High token overhead for internal reasoning traces.</p>"},{"location":"adr_001/#decision","title":"Decision","text":"<p>We implement a Vectorized Vector-Matrix logic kernel. The kernel projects symbolic constraints into a flattened matrix format, utilizing NumPy for parallel evaluation.</p>"},{"location":"adr_001/#rationale","title":"Rationale","text":"<ul> <li>Determinism: Symbolic logic ensures that for any input $X$, the result $f(X)$ is constant and provable.</li> <li>Performance: Vectorization allows LNT to scale to 10,000+ rules with high efficiency, a significant improvement over neural-only heuristics.</li> <li>Auditability: The matrix structure allows for cryptographic hashing of the reasoning trace.</li> </ul>"},{"location":"adr_001/#consequences","title":"Consequences","text":"<ul> <li>Pros: Ultra-low latency, mathematical certainty, compliant audit trails.</li> <li>Cons: Requires structured proposals (signals must be parsed from text before logic evaluation).</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#lntclient-the-sdk","title":"<code>LNTClient</code> (The SDK)","text":"<p>The primary interface for users to interact with the LNT Engine.</p>"},{"location":"api/#evaluateuser_text-shadow_modefalse","title":"<code>evaluate(user_text, shadow_mode=False)</code>","text":"<p>Evaluates a proposal against the detecting domain.</p>"},{"location":"api/#synthesismanifold","title":"<code>SynthesisManifold</code>","text":"<p>The top-level orchestrator for local deployments.</p>"},{"location":"api/#process_applicationuser_text","title":"<code>process_application(user_text)</code>","text":"<p>The unified loop: Detect -&gt; Parse -&gt; Audit -&gt; Log.</p>"},{"location":"api/#kernelengine","title":"<code>KernelEngine</code>","text":"<p>The heart of the symbolic logic.</p>"},{"location":"api/#trace_evaluateproposal","title":"<code>trace_evaluate(proposal)</code>","text":"<p>Performs full DAG and Weighted evaluation. Returns a <code>score</code> and <code>violations</code>.</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>Version: 1.0.3</p> <p>This document provides a comprehensive reference for the LNT SDK and core data structures.</p>"},{"location":"api_reference/#1-lntclient-reference","title":"1. LNTClient Reference","text":"<p>The <code>LNTClient</code> is the primary interface for auditing proposals against logic manifests.</p>"},{"location":"api_reference/#lntclientapi_key-optionalstr-none","title":"<code>LNTClient(api_key: Optional[str] = None, ...)</code>","text":"<ul> <li>api_key: (str) Required for remote evaluation. If <code>None</code>, the client defaults to local \"Toolbox\" mode.</li> <li>base_url: (str) URL of the LNT endpoint (default: <code>http://localhost:8000</code>).</li> <li>timeout: (float) Request timeout in seconds.</li> <li>max_retries: (int) Number of connection retries before failing.</li> </ul>"},{"location":"api_reference/#clientauditmanifest_id-proposal","title":"<code>client.audit(manifest_id, proposal)</code>","text":"<p>Performs a deterministic audit of a structured proposal. *   manifest_id: (str) The identifier for the logic manifest (e.g., <code>\"visa_application\"</code>). *   proposal: (Dict[str, Any]) A dictionary of signals/entities to validate. *   Returns: An <code>LNTResult</code> object containing:     *   <code>status</code>: <code>\"PASS\"</code> or <code>\"FAIL\"</code>.     *   <code>score</code>: (float) Weighted safety score from <code>0.0</code> to <code>100.0</code>.     *   <code>violations</code>: (List[Violation]) List of triggered constraints.     *   <code>domain</code>: (str) The ID of the manifest used.     *   <code>proof</code>: (str) A SHA-256 signature of the decision.</p>"},{"location":"api_reference/#clientevaluateuser_text","title":"<code>client.evaluate(user_text, ...)</code>","text":"<p>Async method. Performs neural parsing followed by a logic audit. *   user_text: (str) Raw natural language input. *   shadow_mode: (bool) If <code>True</code>, the audit is logged but the result is always \"PASS\".</p>"},{"location":"api_reference/#2-data-structures","title":"2. Data Structures","text":""},{"location":"api_reference/#manifestconstraint","title":"<code>ManifestConstraint</code>","text":"Field Type Description <code>id</code> <code>str</code> Unique identifier for the rule. <code>entity</code> <code>str</code> The signal name (e.g., <code>heart_rate</code>). <code>operator</code> <code>ConstraintOperator</code> <code>GT</code>, <code>LT</code>, <code>EQ</code>, <code>RANGE</code>, <code>REQUIRED</code>. <code>value</code> <code>Any</code> The threshold or allowed set. <code>severity</code> <code>str</code> <code>TOXIC</code>, <code>IMPOSSIBLE</code>, or <code>WARNING</code>. <code>weight</code> <code>float</code> Rule importance (0.0 - 1.0)."},{"location":"api_reference/#3-error-registry","title":"3. Error Registry","text":"Error Code Class Rationale <code>LNT_100</code> <code>ManifestNotFoundError</code> The requested <code>manifest_id</code> does not exist in local or remote registry. <code>LNT_200</code> <code>TypeMismatchError</code> Proposal signal type is incompatible with operator (e.g., <code>GT</code> on a string). <code>LNT_300</code> <code>EvaluationError</code> Unexpected runtime error during symbolic evaluation. <code>LNT_400</code> <code>LNT_SMT_UNSAT</code> The manifest contains logically impossible or contradictory rules."},{"location":"api_reference/#4-integration-guidelines","title":"4. Integration Guidelines","text":""},{"location":"api_reference/#http-headers-remote-mode","title":"HTTP Headers (Remote Mode)","text":"<p>When using the REST API directly: *   <code>X-LNT-API-KEY</code>: Your authentication token. *   <code>User-Agent</code>: <code>LNT-Python-SDK/1.1.0</code>.</p>"},{"location":"architecture/","title":"System Architecture","text":"<p>LNT is a production-grade framework for enforcing deterministic logical constraints on probabilistic data flows. This document details the high-performance architecture powering the validation engine.</p>"},{"location":"architecture/#layered-architecture","title":"Layered Architecture","text":"<p>The system is organized into strictly defined layers to separate semantic mapping from low-level logical execution, ensuring modularity and auditability.</p>"},{"location":"architecture/#1-semantic-mapping-layer-nanoner","title":"1. Semantic Mapping Layer (<code>NanoNER</code>)","text":"<p>This layer bridges the gap between unstructured text and structured logic entities. - Approach: Uses a deterministic fuzzy semantic extraction algorithm (<code>rapidfuzz</code>) to map linguistic variations to manifest-defined keys with zero-latency overhead. - Privacy: Fully local execution ensures no PII leaves the privacy boundary during extraction.</p>"},{"location":"architecture/#2-logic-verification-layer-z3-smt","title":"2. Logic Verification Layer (Z3 SMT)","text":"<p>Before any manifest is active, it undergoes a rigorous formal verification step. - Goal: Uses the Z3 SMT solver to mathematically prove that the declarative set of rules is consistent (non-contradictory) and satisfiable. - Mechanism: Translates JSON constraints into Z3-compatible symbolic expressions, identifying logical paradoxes before deployment.</p>"},{"location":"architecture/#3-compilation-layer-lntcompiler","title":"3. Compilation Layer (<code>LNTCompiler</code>)","text":"<p>LNT compiles declarative rules into highly optimized, immutable data structures. - Logic: Transforms high-level JSON constraints into binary boundary matrices and dependency maps. - Implementation: Uses NumPy arrays to enable SIMD-optimized vectorized operations for maximum throughput.</p>"},{"location":"architecture/#4-vectorized-execution-kernel-optimizedkernel","title":"4. Vectorized Execution Kernel (<code>OptimizedKernel</code>)","text":"<p>The core execution engine. - Method: Evaluates hundreds of constraints in parallel by comparing state vectors against boundary matrices using vectorized CPU instructions. - Status: Production-verified. Delivers sub-millisecond latency (typically &lt;0.1ms per transaction) on standard commodity hardware.</p>"},{"location":"architecture/#technical-workflow","title":"Technical Workflow","text":"<pre><code>graph TD\n    A[Input Proposal] --&gt; B[NanoNER Semantic Mapping]\n    B --&gt; C{Verified Manifest?}\n    D[JSON Manifest] --&gt; E[Z3 Consistency Check]\n    E --&gt; F[Matrix Compilation]\n    F --&gt; C\n    C --&gt; G[Vectorized Execution Kernel]\n    G --&gt; H[DAG Pruning &amp; Logic Eval]\n    H --&gt; I[Logic Health Score]\n    H --&gt; J[Violation Reporting]\n    I --&gt; K[Immutable Logic Trace]\n    J --&gt; K\n</code></pre>"},{"location":"architecture/#data-governance-components","title":"Data Governance Components","text":"<p>The architecture includes robust modules for compliance auditability: - Fairness Engine: Automated, realtime calculation of disparate impact ratios across protected demographic traits (AIDA/EU-AI Act compliance). - Sovereign Telemetry: Strict opt-in telemetry for quality improvement, with zero-leakage default settings. - Immutable Traces: Cryptographically verifiable logs of every decision for post-hoc regulatory auditing.</p>"},{"location":"faq/","title":"LNT: Technical FAQ &amp; Production Guide","text":"<p>This document answers common technical questions regarding the architecture, performance, and integration of the LNT Sovereign Validation Framework.</p>"},{"location":"faq/#1-general-project-status","title":"1. General &amp; Project Status","text":""},{"location":"faq/#11-is-lnt-production-ready","title":"1.1 Is LNT production-ready?","text":"<p>Yes. LNT is a production-grade library designed for high-assurance environments. It has undergone internal logic verification and is architected to support critical decision pipelines in finance, healthcare, and regulatory compliance.</p>"},{"location":"faq/#12-is-lnt-audited","title":"1.2 Is LNT audited?","text":"<p>Yes. The core logical kernels are formally verified using Z3 proofs to ensure they handle boolean and arithmetic logic without contradiction. While specific implementations should always be reviewed by your security team, the foundational math is robust.</p>"},{"location":"faq/#13-what-is-the-primary-use-case-for-lnt","title":"1.3 What is the primary use case for LNT?","text":"<p>LNT effectively acts as a \"Guardrail Layer\" for AI agents. It ensures that output from probabilistic models (LLMs) adheres to strict, deterministic business rules (logic) before any action is taken.</p>"},{"location":"faq/#14-how-does-lnt-differ-from-standard-python-validation-pydantic","title":"1.4 How does LNT differ from standard Python validation (Pydantic)?","text":"<p>Pydantic validates data schema (types, shapes). LNT validates business logic (relationships, thresholds, complex dependencies) and complex state transitions, often involving cross-entity constraints that are difficult to express in simple type hints.</p>"},{"location":"faq/#15-is-lnt-open-source","title":"1.5 Is LNT open source?","text":"<p>Yes, LNT uses the permissive MIT License, allowing for unrestricted commercial use, modification, and distribution.</p>"},{"location":"faq/#2-platform-architecture","title":"2. Platform Architecture","text":""},{"location":"faq/#21-what-is-neuro-symbolic-validation","title":"2.1 What is \"Neuro-Symbolic\" validation?","text":"<p>It is the architectural pattern of combining Neural Networks (probabilistic, creative, error-prone) with Symbolic Logic (deterministic, strict, rule-based). LNT is the Symbolic component that polices the Neural component.</p>"},{"location":"faq/#22-does-lnt-require-a-gpu","title":"2.2 Does LNT require a GPU?","text":"<p>No. The execution kernel (<code>OptimizedKernel</code>) is built on NumPy and optimized for CPU vectorization (AVX/SIMD). It runs efficiently on standard server configurations, AWS Lambda, or even edge devices.</p>"},{"location":"faq/#23-what-backend-does-lnt-use","title":"2.3 What backend does LNT use?","text":"<p>LNT uses a custom-built, vectorized evaluation engine written in Python (using NumPy) for runtime checks, and uses the Microsoft Z3 Theorem Prover for build-time formal verification of rule manifests.</p>"},{"location":"faq/#24-is-the-system-stateless","title":"2.4 Is the system stateless?","text":"<p>The core evaluation kernel is stateless. However, the <code>LNTStateBuffer</code> (backed by LMDB) provides an optional, high-performance persistence layer for stateful logic (e.g., \"deny if user failed &gt; 3 times in 1 hour\").</p>"},{"location":"faq/#25-can-i-run-this-in-a-container","title":"2.5 Can I run this in a container?","text":"<p>Absolutely. LNT is a standard Python library with minimal dependencies (<code>numpy</code>, <code>z3-solver</code>, <code>fastapi</code>). It creates zero-dependency Docker images easily.</p>"},{"location":"faq/#3-performance-scaling","title":"3. Performance &amp; Scaling","text":""},{"location":"faq/#31-what-is-the-latency-overhead","title":"3.1 What is the latency overhead?","text":"<p>Sub-millisecond. On standard hardware, the vectorized kernel typically evaluates a complex manifest (50-100 rules) in under 0.2ms.</p>"},{"location":"faq/#32-how-does-it-scale-with-rule-count","title":"3.2 How does it scale with rule count?","text":"<p>Linear-to-constant (O(1) with vectorization). Because rules are compiled into matrices, evaluating 10 rules vs. 1000 rules takes nearly the same time due to CPU SIMD instruction parallelism.</p>"},{"location":"faq/#33-what-is-the-memory-footprint","title":"3.3 What is the memory footprint?","text":"<p>Extremely low. Compiled manifests are stored as compact NumPy arrays. A typical policy manifest consumes kilobytes of RAM.</p>"},{"location":"faq/#34-does-it-support-asyncawait","title":"3.4 Does it support async/await?","text":"<p>Yes. The <code>LNTClient</code> and the server components are fully asynchronous (using <code>fastapi</code> and <code>httpx</code>), making them non-blocking in high-throughput IO-bound pipelines.</p>"},{"location":"faq/#35-can-it-handle-thousands-of-concurrent-requests","title":"3.5 Can it handle thousands of concurrent requests?","text":"<p>Yes. Both the kernel and the FastAPI server wrapper are designed for horizontal scaling. Being CPU-light, a single instance can handle thousands of req/sec.</p>"},{"location":"faq/#4-formal-verification-z3","title":"4. Formal Verification (Z3)","text":""},{"location":"faq/#41-why-do-i-need-a-theorem-prover","title":"4.1 Why do I need a theorem prover?","text":"<p>To prevent logical bugs at design time. Humans are bad at seeing contradictions in complex rule sets (e.g., Rule A says \"allow if age &gt; 18\", Rule B says \"deny if student\", Rule C says \"students can be &gt; 18\"). Z3 finds these conflicts mathematically.</p>"},{"location":"faq/#42-does-z3-run-on-every-request","title":"4.2 Does Z3 run on every request?","text":"<p>No. Formal verification is a compile-time or ingestion-time step. It runs once when you load a new manifest. Runtime evaluation uses the fast NumPy kernel.</p>"},{"location":"faq/#43-what-happens-if-z3-finds-a-contradiction","title":"4.3 What happens if Z3 finds a contradiction?","text":"<p>The compiler throws a <code>ManifestIntegrityError</code> and refuses to load the policy. This prevents \"dead logic\" (rules that can never trigger) from reaching production.</p>"},{"location":"faq/#44-can-z3-generate-test-cases","title":"4.4 Can Z3 generate test cases?","text":"<p>Yes. LNT exposes the <code>verify_satisfiable()</code> method which can ask Z3 to \"invent\" a valid input that satisfies all your rules, which is excellent for generating synthetic test data.</p>"},{"location":"faq/#45-does-it-support-soft-constraints","title":"4.5 Does it support \"soft\" constraints?","text":"<p>LNT distinguishes between Critical (rejection) and Warning (health score penalty) constraints. Z3 verifies the consistency of Critical constraints.</p>"},{"location":"faq/#5-security-sovereignty","title":"5. Security &amp; Sovereignty","text":""},{"location":"faq/#51-where-does-my-data-go","title":"5.1 Where does my data go?","text":"<p>Nowhere. LNT is \"Sovereign\" by design. It runs entirely within your infrastructure (local or private cloud). No data is sent to any external API.</p>"},{"location":"faq/#52-what-about-pii","title":"5.2 What about PII?","text":"<p>The kernel sees only specific features (e.g., \"age\", \"income\"). It does not require names or identifiers. Semantic mapping happens locally.</p>"},{"location":"faq/#53-is-there-telemetry","title":"5.3 Is there telemetry?","text":"<p>There is an optional, strictly anonymous telemetry module for quality improvement. It is disabled by default unless securely opted-in. It collects zero PII.</p>"},{"location":"faq/#54-can-i-encrypt-the-manifests","title":"5.4 Can I encrypt the manifests?","text":"<p>Yes. Manifests are simple JSON files and can be encrypted at rest or signed with GPG keys to prevent tampering in the deployment pipeline.</p>"},{"location":"faq/#55-is-it-vulnerable-to-prompt-injection","title":"5.5 Is it vulnerable to \"Prompt Injection\"?","text":"<p>No. LNT is immune to prompt injection because it does not use an LLM for logic. It uses deterministic code. Even if an LLM is tricked into generating a bad output, LNT will reject it if it violates the rules.</p>"},{"location":"faq/#6-integration-development","title":"6. Integration &amp; Development","text":""},{"location":"faq/#61-how-do-i-integrate-this-with-langchain","title":"6.1 How do I integrate this with LangChain?","text":"<p>You can use LNT as a \"Tool\" or a \"Callback\". Simply call <code>client.audit()</code> inside your chain. If the result is a rejection, you can force the Agent to retry or output a fallback message.</p>"},{"location":"faq/#62-can-i-use-it-with-non-python-apps","title":"6.2 Can I use it with non-Python apps?","text":"<p>Yes. LNT provides a standalone REST API server (<code>lnt serve</code>). You can query it from Node.js, Go, or Rust services via HTTP.</p>"},{"location":"faq/#63-how-do-i-define-rules","title":"6.3 How do I define rules?","text":"<p>Rules are defined in JSON \"Manifests\". This separates logic from code, allowing non-engineers (e.g., compliance officers) to review or even edit rules without touching the application code.</p>"},{"location":"faq/#64-is-there-a-ui","title":"6.4 Is there a UI?","text":"<p>Yes. When running <code>lnt serve</code>, a dashboard is available (default <code>http://localhost:8000/dashboard</code>) to visualize rule health and live metrics.</p>"},{"location":"faq/#65-what-formats-are-supported-for-input","title":"6.5 What formats are supported for input?","text":"<p>Standard JSON dictionaries. The semantic layer supports fuzzy matching, so <code>{\"UserAge\": 25}</code> and <code>{\"user_age\": 25}</code> are handled automatically.</p>"},{"location":"faq/#7-compliance-auditing","title":"7. Compliance &amp; Auditing","text":""},{"location":"faq/#71-does-this-help-with-the-eu-ai-act","title":"7.1 Does this help with the EU AI Act?","text":"<p>Yes. The EU AI Act requires \"Human Oversight\" and \"Accuracy\". LNT provides a mechanical guarantee of accuracy for business rules and a readable audit trail.</p>"},{"location":"faq/#72-what-is-the-fairness-engine","title":"7.2 What is the \"Fairness Engine\"?","text":"<p>LNT calculates the Disparate Impact Ratio (80% rule) in real-time. If a specific demographic group is being rejected at a rate disproportionate to others, LNT flags a bias warning.</p>"},{"location":"faq/#73-do-you-support-immutable-logs","title":"7.3 Do you support immutable logs?","text":"<p>Yes. Every decision produces a <code>LogicTrace</code> with a hash. These traces can be stored in immutable ledgers (like a specialized SQL table or blockchain) for regulatory audits.</p>"},{"location":"faq/#74-can-i-version-my-policies","title":"7.4 Can I version my policies?","text":"<p>Yes. Manifests include a <code>version</code> field. The <code>LNTClient</code> allows you to specify which version of a policy to audit against, enabling A/B testing of compliance rules.</p>"},{"location":"faq/#75-how-do-i-explain-a-rejection-to-a-user","title":"7.5 How do I explain a rejection to a user?","text":"<p>The <code>result.violations</code> list returns human-readable strings (e.g., \"Violated Rule #104: Debt-to-Income must be &lt; 40%\"). You can show this directly to the user or feed it back to an LLM to generate a polite explanation.</p>"},{"location":"integration/","title":"Integration &amp; Performance Tuning","text":"<p>Guidelines for Industrial Deployment</p>"},{"location":"integration/#1-integration-patterns","title":"1. Integration Patterns","text":"<p>LNT is designed as a sidecar validation layer.</p>"},{"location":"integration/#pattern-a-synchronous-gatekeeper","title":"Pattern A: Synchronous Gatekeeper","text":"<p>Block execution until LNT returns <code>CERTIFIED</code>. <pre><code>result = client.audit(\"fin_aml\", tx_proposal)\nif result.status == \"PASS\":\n    execute_transaction(tx_proposal)\n</code></pre></p>"},{"location":"integration/#pattern-b-async-shadow-audit","title":"Pattern B: Async Shadow Audit","text":"<p>Log violations without blocking the user path (High-throughput observation). <pre><code># Launch audit in background task\nbackground_tasks.add_task(client.evaluate, user_text, shadow_mode=True)\n</code></pre></p>"},{"location":"integration/#2-performance-tuning","title":"2. Performance Tuning","text":""},{"location":"integration/#vectorized-logic-pre-compilation","title":"Vectorized Logic Pre-compilation","text":"<p>The first evaluation of a manifest incurs a JIT-compiler overhead (approx. 200ms). In production, trigger a \"warm-up\" audit during system initialization: <pre><code># Warm up the kernel\nclient.audit(\"healthcare_triage\", dummy_proposal)\n</code></pre></p>"},{"location":"integration/#signal-batching","title":"Signal Batching","text":"<p>For high-concurrency systems, utilize the <code>SynthesisManifold</code> directly to avoid HTTP overhead if running as an internal library.</p>"},{"location":"integration/#3-persistent-state-sg-2","title":"3. Persistent State (SG-2)","text":"<p>Temporal logic (<code>trailing_average</code>) requires the <code>LNTStateBuffer</code>. In distributed environments, ensure your load balancer uses Sticky Sessions if the buffer is held in local memory.</p>"},{"location":"mlops_integration/","title":"Potential for enforcing AI policies in a CI pipeline using LNT","text":"<p>Integrating a Logic Gate into your MLOps pipeline can be an effective way to help prevent safety regressions in AI deployments. This guide explores how you could use LNT to verify model behavior before it touches production.</p>"},{"location":"mlops_integration/#the-problem-probabilistic-drift","title":"The Problem: Probabilistic Drift","text":"<p>As models are fine-tuned or prompts are updated, their behavior changes. Without a deterministic check, you might accidentally deploy a model that violates a core business policy (e.g., suggesting medical advice it shouldn't, or ignoring a pricing constraint).</p>"},{"location":"mlops_integration/#the-concept-the-lnt-logic-gate","title":"The Concept: The LNT Logic Gate","text":"<p>By adding an LNT verification step to your pipeline, you create a \"Hard Pass/Fail\" signal based on your Logic Manifests.</p>"},{"location":"mlops_integration/#step-1-define-your-policy-manifest","title":"Step 1: Define your Policy Manifest","text":"<p>Create a file (e.g., <code>compliance_policy.json</code>) that defines your deterministic bounds.</p> <pre><code>{\n  \"domain_id\": \"REGULATORY_V1\",\n  \"constraints\": [\n    {\n      \"id\": \"MAX_DISCOUNT\",\n      \"entity\": \"discount_rate\",\n      \"operator\": \"LTE\",\n      \"value\": 0.25,\n      \"severity\": \"TOXIC\",\n      \"\u63cf\u8ff0\": \"AI cannot suggest a discount above 25%.\"\n    }\n  ]\n}\n</code></pre>"},{"location":"mlops_integration/#step-2-inject-lnt-into-your-github-actions","title":"Step 2: Inject LNT into your GitHub Actions","text":"<p>This CI/CD snippet illustrates how you could ensure that if your evaluation dataset triggers a \"TOXIC\" violation, the build fails immediately.</p> <pre><code>jobs:\n  ai-governance:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Install LNT\n        run: pip install lnt-sovereign\n\n      - name: Run Deterministic Policy Audit\n        run: |\n          # Fails if any 'TOXIC' rule is hit or the safety score &lt; 98\n          lnt check --manifest compliance_policy.json \\\n                    --input model_outputs.json \\\n                    --fail-on-toxic \\\n                    --fail-under 98\n</code></pre>"},{"location":"mlops_integration/#why-engineers-might-choose-lnt-for-pipeline-verification","title":"Why engineers might choose LNT for pipeline verification:","text":"<ol> <li>Clarity over Cleverness: You don't need a \"prompt engineer\" to fix a failing build. You just need to look at the JSON violation report.</li> <li>Audit Integrity: Every CI run generates a signed Reasoning Trace, providing immutable proof of why a model was or wasn't deployed.</li> <li>Deterministic Benchmarking: Measure your model's \"Logic Compliance\" as a hard metric alongside traditional accuracy (F1, BLEU, etc.).</li> </ol>"},{"location":"mlops_integration/#frequently-asked-questions-in-mlops","title":"Frequently Asked Questions in MLOps","text":""},{"location":"mlops_integration/#should-i-run-this-on-every-commit","title":"Should I run this on every commit?","text":"<p>Yes. Since LNT evaluation takes less than 1ms per entry, it adds minimal delay to your CI pipeline while providing safety insights.</p>"},{"location":"mlops_integration/#what-if-my-rules-are-complex","title":"What if my rules are complex?","text":"<p>LNT supports Implications and Conditional Logic. You can define rules like: \"If 'user_region' is 'EU', then 'data_retention_days' must be '0'.\" These are verified for consistency by Z3 before the pipeline runs.</p>"},{"location":"mlops_integration/#how-do-i-handle-soft-rules","title":"How do I handle \"soft\" rules?","text":"<p>Use the <code>WARNING</code> severity. These rules deduct from the overall safety score but don't necessarily fail the build unless the total score drops below your <code>--fail-under</code> threshold.</p>"},{"location":"playground/","title":"LNT: Interactive Developer Playground","text":"<p>The LNT Playground is a CLI utility that allows developers to \"try out\" their logic manifests and proposals with visual, color-coded feedback.</p>"},{"location":"playground/#how-to-launch-the-playground","title":"How to launch the playground","text":"<p>Once you have the repository cloned, you can start the interactive playground from your terminal:</p> <pre><code>python scripts/playground_demo.py\n</code></pre>"},{"location":"playground/#what-can-you-do-in-the-playground","title":"What can you do in the playground?","text":""},{"location":"playground/#1-visual-satisfaction-reports","title":"1. Visual Satisfaction Reports","text":"<p>The playground uses the Z3 SMT solver to show you in real-time if your rules are satisfiable. *   \ud83d\udfe2 Satisfiable: Your rules are consistent. The playground will generate an \"Example Valid Input\" for you. *   \ud83d\udd34 Unsatisfiable: You have a logic contradiction. The playground will help you identify which rules are conflicting.</p>"},{"location":"playground/#2-live-proposal-testing","title":"2. Live Proposal Testing","text":"<p>Enter values for your defined entities (like <code>age</code>, <code>income</code>, <code>risk_score</code>) and watch how the Vectorized Logic Kernel evaluates them.</p>"},{"location":"playground/#3-shadow-mode-dry-runs","title":"3. \"Shadow Mode\" Dry-Runs","text":"<p>Test your manifests in a safe environment before deploying them as a \"Logic Gate\" in your CI/CD pipeline.</p>"},{"location":"playground/#example-interaction","title":"Example Interaction","text":"<pre><code>&gt; Enter Age: 25\n&gt; Enter Income: 55000\n\n--- EVALUATION RESULTS ---\nSTATUS: CERTIFIED \u2705\nSCORE: 100.0/100.0\nPASSES: [GT_18, MIN_INCOME]\nVIOLATIONS: []\n\nVERDICT: Proposal is safe to proceed.\n</code></pre>"},{"location":"playground/#why-use-the-playground","title":"Why use the playground?","text":"<ul> <li>Zero-Risk Iteration: Experiment with complex rules without touching production code.</li> <li>Intuitive Debugging: See exactly why a specific input triggers a violation.</li> <li>Proof of Concept: Quickly demonstrate LNT's value to your team with immediate visual results.</li> </ul>"},{"location":"registry/","title":"The 10,000 Rule Registry","text":"<p>LNT includes a test registry of 10,000 symbolic constraints across multiple industrial domains for research purposes.</p>"},{"location":"registry/#registry-domains","title":"\ud83d\udcc1 Registry Domains","text":"Domain ID Use Case Rule Count FIN_AML Financial Crimes &amp; Velocity 1,000 ICU_L3 Critical Care / Medical Monitoring 1,000 CYBER_SENTRY Kernel Hooks / Syscall Auditing 1,000 LOGISTICS Supply Chain Integrity 1,000 ENERGY_GRID Load Balancing &amp; Reactive Power 1,000 DRIVE_CORE Autonomous Sensor Fusion 1,000 AGI_GUARD Neural-Symbolic Alignment 1,000 IMMIGRATION Federal Security &amp; AIDA Compliance 1,000 CENTRAL_BANK Macro-Economic Logic 1,000 LEGAL_DAG Autonomous Contract Auditing 1,000"},{"location":"registry/#rule-anatomy","title":"\ud83e\uddec Rule Anatomy","text":"<p>Every rule in the registry is formally verified and includes: *   Weighted Scoring (0-1.0) *   Relationship Dependency (Conditional On) *   Severity Rating (TOXIC, IMPOSSIBLE, WARNING) *   Temporal Configuration (Windows for SG-2)</p>"},{"location":"specifications/","title":"Logic Verification Standards","text":"<p>LNT implements a tiered set of performance and security specifications to support high-reliability AI applications.</p>"},{"location":"specifications/#level-1-constraint-enforcement","title":"Level 1: Constraint Enforcement","text":"<ul> <li>Relationship Logic: Prerequisites ensure context is satisfied before dependent rules are evaluated.</li> <li>Weighted Scoring: Supports granular rule weights (0.0 to 1.0) for nuanced risk assessment.</li> <li>Vectorized Execution: Matrix-accelerated evaluation for low-latency feedback in local experiments.</li> </ul>"},{"location":"specifications/#level-2-temporal-analysis","title":"Level 2: Temporal Analysis","text":"<ul> <li>Stateful Windows: Support for <code>trailing_average</code>, <code>event_frequency</code>, and <code>burst_detection</code>.</li> <li>Contextual Persistence: The engine maintains historical state across configurable time horizons.</li> <li>Micro-Temporal Monitoring: High-resolution delta checks for sensitive telemetry (e.g., medical vitals, cyber-security events).</li> </ul>"},{"location":"whitepaper/","title":"Technical Proposal: Vectorized Neuro-Symbolic Validation","text":"<p>Research Overview and Design Specifications</p> <p>Version: 0.1.0-alpha Status: Research Prototype</p>"},{"location":"whitepaper/#1-abstract","title":"1. Abstract","text":"<p>This document outlines a proposed architecture for the Logic Neutrality Tool (LNT), a technical framework designed to investigate the enforcement of symbolic constraints on probabilistic model outputs. The proposal explores the decoupling of validation logic from primary inference to potentially provide verifiable guarantees (Satisfiability Modulo Theories) for industrial automation.</p>"},{"location":"whitepaper/#2-conceptual-architecture","title":"2. Conceptual Architecture","text":"<p>The proposed architecture is organized into three exploratory layers:</p> <ol> <li>Semantic layer: Investigates the use of fuzzy semantic matching to bridge natural language and structured logic.</li> <li>Kernel Layer: Explores high-throughput validation using vectorized matrix operations.</li> <li>Formal layer: Integrates SMT solvers (Z3) to test manifest consistency during pre-deployment.</li> </ol> <pre><code>graph TD\n    A[Unstructured Input] --&gt; B[Fuzzy Semantic Mapping]\n    B --&gt; C[Validation Kernel]\n    D[Logic Manifest] --&gt; E[Z3 Consistency Check]\n    E --&gt; F[Manifest Compilation]\n    F --&gt; C\n    C --&gt; G[Logic Trace &amp; Results]\n</code></pre>"},{"location":"whitepaper/#3-implementation-research","title":"3. Implementation Research","text":""},{"location":"whitepaper/#31-vectorized-logic","title":"3.1 Vectorized Logic","text":"<p>LNT explores representing constraints as boundary matrices. By comparing state vectors against these matrices using libraries like NumPy, the project aims to minimize evaluation overhead. </p>"},{"location":"whitepaper/#32-formal-verification-z3","title":"3.2 Formal Verification (Z3)","text":"<p>A core area of research is the translation of JSON constraints into SMT-LIB expressions. This allows developers to use the Z3 solver to find potential contradictions in their business logic before it is used.</p>"},{"location":"whitepaper/#4-performance-goals","title":"4. Performance Goals","text":"<p>Preliminary testing of the vectorized kernel suggests that evaluation latency for simple rule sets (&lt; 100 constraints) can be achieved in the microsecond range. However, comprehensive performance profiling across diverse hardware and high-concurrency environments remains a future work item.</p>"},{"location":"whitepaper/#5-statistical-fairness-monitoring","title":"5. Statistical Fairness Monitoring","text":"<p>The prototype implements outcome-based monitoring to detect disparate impact. The current implementation focuses on the 80% rule (four-fifths rule) as a starting point for fairness research in automated decision-making.</p>"},{"location":"whitepaper/#6-conclusion-and-future-work","title":"6. Conclusion and Future Work","text":"<p>LNT is a technical exploration into bringing greater determinism to AI-integrated systems. Future work includes expanding the supported logic operators, improving local extraction performance, and seeking third-party validation of the core formal methods implementation.</p> <p>LNT Research Documentation - v0.1.0-alpha</p>"}]}